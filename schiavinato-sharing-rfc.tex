\documentclass[10pt, twocolumn]{article}

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm} % For math equations
\usepackage{geometry} % Margins
\usepackage[breaklinks]{hyperref} % Links (Added breaklinks for safety)
\usepackage{url}
\usepackage{fancyhdr} % Headers
\usepackage{titlesec} % Section formatting
\usepackage{booktabs} % Professional tables
\usepackage{enumitem} % Better lists
\usepackage{microtype} % Better typography
\usepackage{graphicx} % Required to resize tables

% --- Formatting ---
\geometry{a4paper, margin=0.75in}
\setlength{\columnsep}{0.25in}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={Schiavinato Sharing: Human-Executable Secret Sharing for BIP39 Mnemonics},
    pdfauthor={GRIFORTIS}
}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small \textbf{Schiavinato Sharing (RFC)}}
\fancyhead[R]{\small \today}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}

% Section Title Spacing
\titlespacing{\section}{0pt}{12pt plus 4pt minus 2pt}{4pt plus 2pt minus 2pt}
\titlespacing{\subsection}{0pt}{10pt plus 4pt minus 2pt}{3pt plus 2pt minus 2pt}
\titlespacing{\subsubsection}{0pt}{8pt plus 4pt minus 2pt}{2pt plus 2pt minus 2pt}

% --- Title Data ---
\title{\vspace{-1cm} \textbf{\Large Schiavinato Sharing: Human-Executable Secret Sharing for BIP39 Mnemonics} \\ \large A Pencil-and-Paper Arithmetic Scheme for Inheritance and Disaster Recovery}
\author{\textbf{GRIFORTIS} \\ \url{https://github.com/GRIFORTIS}}
\date{\today \\ \small \textit{Status: Request for Comments (RFC)}}

\begin{document}

% Makes LaTeX less fussy about spacing in narrow columns (Fixes Underfull warnings)
\sloppy

\maketitle

\begin{abstract}
\noindent The Schiavinato BIP39 Mnemonic Sharing Scheme (or \textbf{Schiavinato Sharing}) is a threshold secret-sharing scheme for BIP39 mnemonics, designed explicitly for recovery with pencil and paper. It instantiates Shamir's Secret Sharing over the prime field $GF(2053)$, operating directly on BIP39 word indices rather than on the underlying binary entropy. Each word index is sharded independently by a random polynomial, and additional checksum secrets provide robust detection of human arithmetic errors during manual recovery. By pre-computing Lagrange coefficients for common threshold schemes, the scheme reduces recovery to a sequence of additions and multiplications modulo 2053. A reference implementation architecture by GRIFORTIS is outlined, based on an auditable, offline HTML tool and MIT-licensed libraries for Python and JavaScript, enabling independent verification and potential integration while preserving the security guarantees of standard Shamir secret sharing.
\end{abstract}

\section{Introduction}

\subsection{The Inheritance Problem in a Digital Age}
The widespread use of cryptocurrencies and other digital bearer assets has created a new inheritance problem. Long-term control over these assets is typically anchored to a single secret, such as a 24-word BIP39 mnemonic. If this secret is lost or destroyed, the assets are unrecoverable; if it is exposed, the assets can be stolen. Traditional backup strategies (for example, a single steel plate in a safe) concentrate risk and often fail to account for multi-generational time horizons.

Threshold cryptography and secret sharing offer a principled way to spread this risk. Instead of a single point of failure, a secret is divided into multiple shares, of which any $k$ out of $n$ are sufficient for recovery. However, most deployed schemes assume the presence of trusted electronics at the time of recovery. For true disaster resilience, it is desirable to have recovery paths that remain viable even when access to compatible hardware, software, or networks is temporarily or permanently unavailable, or compromised.

\subsection{Existing Solutions and Their Limitations}
Several practical solutions exist today:
\begin{itemize}[noitemsep]
    \item \textbf{Hardware wallets and single backups} rely on secure devices and careful handling of a single mnemonic. They are simple to operate but remain vulnerable to single-point failure and to latent user errors in backup procedures.
    \item \textbf{Multisignature wallets} distribute signing authority but require ongoing coordination of multiple keys, devices, and software stacks. They do not, by themselves, solve the problem of how each individual key is backed up or inherited.
    \item \textbf{Computational Shamir schemes}, such as SLIP39 and SSKR, apply Shamir's Secret Sharing at the level of binary entropy, typically over extension fields $GF(2^n)$. These schemes are well-studied and robust, but the field arithmetic---especially multiplication and inversion in $GF(2^n)$---is unsuitable for manual execution. In practice, users must depend on specific software or hardware implementations for both sharding and recovery.
\end{itemize}

In all these cases, the recovery procedure is ultimately a computational protocol. If an appropriate device is not available at the time of recovery, or if the software ecosystem has changed in incompatible ways, long-term access to the assets is jeopardized.

\subsection{A Non-Computational Approach}
Schiavinato Sharing is designed to remove this dependency on trusted electronics at the point of recovery. The central design goals are:
\begin{enumerate}[noitemsep]
    \item \textbf{Human executability}: All required operations for sharding and recovery can be performed with pencil, paper, and basic arithmetic skills.
    \item \textbf{Cryptographic soundness}: Security should reduce to that of standard Shamir secret sharing in a well-understood field.
    \item \textbf{BIP39 compatibility}: The scheme should accept and output standard BIP39 mnemonics, without requiring modified wordlists or custom checksum rules.
    \item \textbf{Auditability and simplicity}: The construction should be simple enough to be understood, audited, and reimplemented by third parties, and the reference implementations must be fully offline and open source.
\end{enumerate}

To achieve these goals, Schiavinato Sharing transposes Shamir's Secret Sharing from extension fields $GF(2^n)$ to a small prime field $GF(2053)$ and operates directly on BIP39 word indices. It further introduces a two-layer arithmetic checksum mechanism to detect human calculation errors during manual recovery.

\subsection{Status and Responsible Use}
This document presents Schiavinato Sharing as a \textbf{proposed construction} and reference design. While its security reduces to well-understood components (Shamir's Secret Sharing in a prime field and standard BIP39 assumptions), the scheme itself, its human workflows, and any concrete implementations \textbf{require independent review, testing, and peer scrutiny}.

At the time of writing, Schiavinato Sharing and any GRIFORTIS reference tools that implement it should be regarded as \textbf{experimental and unaudited}. They are appropriate for education, testing, and community review, but \textbf{are not yet recommended for securing significant real-world holdings} without additional independent analysis or professional review.

In particular:
\begin{itemize}[noitemsep]
    \item The mathematics is conventional, but subtle implementation bugs, user-interface flaws, or misunderstandings of the procedures can still cause \textbf{permanent loss of funds}.
    \item No whitepaper or reference implementation, including this one, should be treated as a substitute for careful threat modeling, operational planning, and, where appropriate, professional advice.
\end{itemize}

Early adopters are encouraged to:
\begin{itemize}[noitemsep]
    \item Start with \textbf{modest amounts} and well-documented drills before entrusting a large fraction of long-term savings to any new scheme.
    \item Treat the GRIFORTIS tools as \textbf{reference implementations}, not as the only or final word on how the scheme should be realized in software.
    \item Report issues, ambiguities, or suspected vulnerabilities through the project's responsible disclosure channels so that the design and documentation can be improved over time.
\end{itemize}

Nothing in this paper constitutes financial, legal, or tax advice. Users remain responsible for their own operational and regulatory choices.

\section{Background: The Mathematical Foundations}
Schiavinato Sharing is a concrete application of established cryptographic principles. It does not introduce a new primitive; instead, it adapts Shamir's Secret Sharing to a setting where every operation can, in principle, be performed by hand.

This section sketches the relevant mathematical background. Readers who require additional detail can consult the appendices and the referenced literature.

\begin{itemize}
    \item \textbf{Shamir's Secret Sharing (SSS)}: A threshold secret-sharing scheme in which a secret value is interpreted as the constant term of a polynomial over a finite field. Shares are evaluations of this polynomial at non-zero points; any $k$ shares determine the polynomial uniquely, while fewer than $k$ yield no information about the secret (see \textbf{Appendix A}).
    \item \textbf{Modular arithmetic}: Arithmetic performed ``modulo'' a fixed number $p$, where values are always taken in the range $\{0, 1, \dots, p-1\}$. Addition and multiplication are defined as usual, followed by reduction modulo $p$. When $p$ is prime, every non-zero value has a multiplicative inverse, which enables division (see \textbf{Appendix B}).
    \item \textbf{Lagrange interpolation}: A method to reconstruct a polynomial of degree at most $k-1$ from $k$ distinct points. For Shamir's scheme, we are primarily interested in the constant term (the secret). By pre-computing the relevant Lagrange coefficients for a given set of share indices, reconstruction reduces to a weighted sum of the share values (see \textbf{Appendix C}).
\end{itemize}

By working over a prime field $GF(p)$ with a carefully chosen prime $p$, Schiavinato Sharing ensures that all of the above can be instantiated with straightforward integer arithmetic.

\section{Schiavinato Sharing: An Arithmetic Approach}

\emph{Note: While the examples in this paper assume a 24-word BIP39 mnemonic, the same construction applies, mutatis mutandis, to 12, 15, 18, and 21-word phrases.}

\subsection{The Challenge of Non-Computational Recovery}
Standard implementations of Shamir's Secret Sharing for wallet backups, such as SLIP39 and SSKR, operate on the binary entropy underlying the mnemonic. They typically work in extension fields of the form $GF(2^n)$, such as $GF(2^8)$. Arithmetic in these fields is expressed in terms of polynomials over $GF(2)$ reduced modulo an irreducible polynomial. While efficient for microprocessors, this representation makes multiplication and inversion opaque and laborious for humans.

Moreover, entropy-based schemes require explicit conversion between the binary entropy and the mnemonic words, including verification of the BIP39 checksum bits. Reversing this process by hand---mapping words to indices, expanding to a bitstring, separating entropy from checksum, and possibly re-encoding is beyond what can reasonably be expected in a manual recovery scenario.

In contrast, Schiavinato Sharing operates directly on BIP39 word indices in a small prime field. Recovery never requires manipulating bits or recomputing the BIP39 checksum by hand. All visible operations are integer additions and multiplications modulo a fixed prime.

\subsection{Methodology: Independent Polynomials in a Prime Field}
The core innovation of Schiavinato Sharing is to instantiate Shamir's Secret Sharing over the prime field $GF(p)$ with
\[ p = 2053, \]
the smallest prime greater than the BIP39 wordlist size of 2048.

The rationale for this choice is threefold:
\begin{enumerate}[noitemsep]
    \item \textbf{Coverage of all word indices}: Every BIP39 word index (0--2047) is representable as an element of $GF(2053)$ without any encoding overhead.
    \item \textbf{Simplicity of operations}: Working in a prime field eliminates the need for polynomial representations and enables straightforward integer arithmetic with reduction modulo $p$.
    \item \textbf{Security properties}: $GF(2053)$ is a standard finite field with no evident structure that would weaken Shamir's guarantees. Each sharing instance has a search space of size $p$, slightly larger than the 2048-word mnemonic space.
\end{enumerate}

A 24-word BIP39 mnemonic is treated as a vector of 24 integers $(w_1, \dots, w_{24})$, each in $\{0, \dots, 2047\}$. While these indices are not 24 fully independent 11-bit variables---because of the BIP39 checksum and the way entropy is mapped to words---they collectively encode a 256-bit entropy value plus checksum bits. For the purposes of the security analysis, it is sufficient to note that the effective keyspace remains on the order of $2^{256}$.

For a $k$-of-$n$ scheme, Schiavinato Sharing defines, for each secret, an independent polynomial of degree at most $k-1$:
\[ f(x) = a_0 + a_1 x + \dots + a_{k-1} x^{k-1} \pmod{2053} \]
where:
\begin{itemize}[noitemsep]
    \item $a_0$ is the secret value (a word index or a checksum value),
    \item $(a_1, \dots, a_{k-2})$ are independently sampled, cryptographically secure random coefficients in $\{0, \dots, 2052\}$, and
    \item $a_{k-1}$ is an independently sampled, cryptographically secure random coefficient from the non-zero values $\{1, \dots, 2052\}$ to ensure the polynomial has degree exactly $k-1$. For the case $k=1$, there are no random coefficients.
\end{itemize}

This process is repeated independently for every secret used by the scheme:
\begin{itemize}[noitemsep]
    \item the 24 word indices $(w_1, \dots, w_{24})$,
    \item 8 additional row-checksum secrets, one per row of three words (see Section \ref{sec:checksum}), and
    \item 1 \textbf{master verification number} (a global checksum over all 24 words), defined as
    \[ M = \sum_{i=1}^{24} w_i \pmod{2053} \]
\end{itemize}

In total, a 24-word mnemonic uses 33 independent Shamir instances, each with its own polynomial and randomness. The master verification number $M$ is treated exactly like the other secrets: it is shared by an independent polynomial over $GF(2053)$, and only its per-share evaluations appear on individual worksheets. The underlying value $M$ is recovered via Lagrange interpolation during the final verification step of recovery.

\subsection{Manual Share Generation}
Shares can be generated by software or entirely by hand. The reference GRIFORTIS tools automate this process, but the construction remains fully transparent.

For each secret $s \in \{0, \dots, 2052\}$:
\begin{enumerate}
    \item \textbf{Define the secret}: Set $a_0 = s$ in $GF(2053)$.
    \item \textbf{Sample random coefficients}: For a $k$-of-$n$ scheme, sample $(a_1, \dots, a_{k-2})$ as cryptographically secure random integers from $\{0, \dots, 2052\}$ and sample $a_{k-1}$ from $\{1, \dots, 2052\}$ to ensure the polynomial has degree exactly $k-1$.
    \item \textbf{Evaluate the polynomial}: For each share index $x \in \{1, 2, \dots, n\}$, compute
    \[ y = f(x) = a_0 + a_1 x + \dots + a_{k-1} x^{k-1} \pmod{2053} \]
    The resulting pair $(x, y)$ is the share for that secret at index $x$.
\end{enumerate}

In the 24-word case, the collection of secrets $s$ to which this procedure is applied consists of the 24 word indices, the 8 row-checksum values, and the master verification number $M$, for a total of 33 independent polynomials.

This procedure is applied to each of the 33 secrets. For any fixed share index $x$ (for example, $x = 3$), the 33 resulting values (24 word shares, 8 row-checksum shares, and 1 master verification share) together constitute \textbf{one} cryptographic share of the wallet.

\subsection{The Manual Recovery Process}
Recovery in Schiavinato Sharing relies on Lagrange interpolation in $GF(2053)$. Given any $k$ distinct shares $(x_j, y_j)$ for a single secret, the constant term $a_0$ of the underlying polynomial can be expressed as
\[ a_0 = f(0) = \sum_{j=1}^{k} \gamma_j y_j \pmod{2053} \]
where the Lagrange coefficients $\gamma_j$ depend only on the share indices $x_1, \dots, x_k$:
\[ \gamma_j = \prod_{\substack{i=1 \\ i \neq j}}^{k} \frac{x_i}{x_i - x_j} \pmod{2053} \]

In principle, a user could compute these coefficients by hand using modular inverses. In practice, Schiavinato Sharing treats them as \textbf{non-secret metadata}:
\begin{itemize}
    \item For common $k$-of-$n$ schemes (e.g., 2-of-3, 2-of-4, 3-of-5), the reference documentation includes pre-computed Lagrange coefficients for all subsets of indices (Section \ref{sec:precomputed}).
    \item For other schemes, the coefficients can be computed on demand using a simple script or calculator. Since they contain no secret information, this can be done on any convenient device.
\end{itemize}

The manual recovery workflow for a single secret is therefore:
\begin{enumerate}
    \item Determine which $k$ share indices $x_1, \dots, x_k$ you possess.
    \item Look up or compute the corresponding Lagrange coefficients $\gamma_1, \dots, \gamma_k$ for $GF(2053)$.
    \item For each share $j$, multiply the share value $y_j$ by $\gamma_j$ modulo 2053.
    \item Sum the products and reduce modulo 2053 to obtain the recovered secret $a_0$.
\end{enumerate}

\subsection{Integrity and Error Detection: The Two-Layer Checksum} \label{sec:checksum}
Performing dozens of modular multiplications and additions by hand creates ample opportunity for arithmetic mistakes. Because independent word-level sharing destroys the original BIP39 checksum relationship between words, an additional integrity mechanism is required.

Schiavinato Sharing uses a purely arithmetic, two-layer checksum system:

\paragraph{1. Row-level checksums (Shamir-shared):} The 24 words are arranged into 8 rows of 3 words each. For row $r$ with word indices $(w_{r,1}, w_{r,2}, w_{r,3})$, define a checksum secret
\[ c_r = (w_{r,1} + w_{r,2} + w_{r,3}) \pmod{2053} \]
Each $c_r$ is then treated as an additional secret and shared with its own independent Shamir polynomial over $GF(2053)$, exactly as for the word indices. Thus, for each share index $x$, the printed worksheet row contains four values: three word shares and one checksum share.

During recovery, for each row the user:
\begin{itemize}
    \item uses Lagrange interpolation to recover $(w_{r,1}, w_{r,2}, w_{r,3})$, and $c_r$ from their $k$ shares;
    \item computes $\tilde{c}_r = (w_{r,1} + w_{r,2} + w_{r,3}) \pmod{2053}$ by hand; and
    \item verifies that $\tilde{c}_r = c_r$.
\end{itemize}

If this equality fails, there is an arithmetic error affecting at least one of the four recovered values in that row.

\paragraph{2. Master verification number (Shamir-shared):} In addition to the row-level checks, the scheme defines a master verification number
\[ M = \sum_{i=1}^{24} w_i \pmod{2053} \]
computed once from the original 24 words before sharding. This value is treated as a separate secret and shared by its own independent Shamir polynomial over $GF(2053)$, producing one master verification share value on each worksheet.

After all 24 word indices have been recovered, the user performs two calculations:
\begin{itemize}
    \item uses Lagrange interpolation on the master verification shares from their $k$ worksheets to recover $M$, and
    \item separately computes the recomputed master verification number $\tilde{M} = \sum_{i=1}^{24} w_i \pmod{2053}$ from the recovered words.
\end{itemize}

If $\tilde{M} \neq M$, then at least one row contains undetected errors and must be rechecked.

Under a simple model in which an incorrect set of recovered values behaves like a random element of $GF(2053)$, the chance that a wrong triple together with a wrong $c_r$ still satisfies the row equation is at most $1/2053$. With an additional independence assumption across rows, the overall error-escape probability is on the order of $(1/2053)^9$. Even without relying on that assumption, the per-row-plus-master failure probability of at most $1/2053^2$ is negligible for any practical purpose.

\subsection{The Share Format and Recovery Worksheet}
Each individual share document (corresponding to a fixed index $x \in \{1, \dots, n\}$) contains:
\begin{itemize}
    \item \textbf{Header metadata}: Wallet Identifier, Creation Date, Scheme ($k$-of-$n$), Share Number $x$, and the Master verification share value.
    \item \textbf{Body table}: Typically formatted as 8 rows and 4 columns. Columns 1--3 contain word shares (displayed as number + word if $<2048$). Column 4 contains the Checksum share value.
\end{itemize}

Values in the range 2048--2052 (which do not correspond to BIP39 words) are printed as numeric-only values. This consistent layout allows the user to treat each row as a self-contained unit during recovery: recover three words and one checksum, verify them immediately, and then proceed to the next row.

\subsection{Lagrange Coefficients and Manual Recovery} \label{sec:lagrange}

\subsubsection{The Role of Lagrange Coefficients}
A key enabler of manual recovery is the use of pre-computed Lagrange coefficients. In standard polynomial interpolation, determining the polynomial $f(x)$ typically involves solving a system of linear equations or computing the full Lagrange basis. However, for recovering the secret $a_0 = f(0)$, we only need the evaluated value at the origin.

For a fixed set of share indices $S = \{x_1, \dots, x_k\}$, the secret can be expressed as a linear combination of the share values $y_j$:
\[ a_0 = \sum_{j=1}^{k} y_j \gamma_j \pmod{2053} \]
where the Lagrange coefficient $\gamma_j$ for share $x_j$ is defined as:
\[ \gamma_j = \prod_{\substack{i \in S \\ i \neq j}} \frac{x_i}{x_i - x_j} \pmod{2053} \]

These coefficients depend \textit{only} on the subset of share indices used for recovery, not on the secret itself. This separation allows $\gamma_j$ values to be pre-calculated or looked up, transforming the complex task of polynomial interpolation into a straightforward sequence of scalar multiplications and additions.

\subsubsection{Impossibility of Universal Static Coefficients}
A natural usability question arises: is it possible to select a specific set of share indices such that the Lagrange coefficient $\gamma_j$ for a given share remains constant, regardless of which other $k-1$ shares are used for recovery? If such a set existed, a single static multiplier could be printed directly on each share worksheet, drastically simplifying the workflow.

However, this is mathematically impossible for any threshold $k < n$.\footnote{This impossibility holds regardless of field size or characteristic. Exhaustive computational verification confirms that no configuration exists in $GF(2053)$, larger prime fields up to seven digits, or extension fields $GF(2^n)$. The constraint is purely algebraic and admits no exceptions.}

\begin{proof}
Consider the simplest case: a 2-of-3 scheme with distinct indices $x_1, x_2, x_3$.

If we reconstruct using the subset $\{x_1, x_2\}$, the coefficient for share 1 is:
\[ \gamma_{1,\{1,2\}} = \frac{x_2}{x_2 - x_1} \]

If we reconstruct using the subset $\{x_1, x_3\}$, the coefficient for share 1 is:
\[ \gamma_{1,\{1,3\}} = \frac{x_3}{x_3 - x_1} \]

For these coefficients to be identical (universal), we require:
\[ \frac{x_2}{x_2 - x_1} = \frac{x_3}{x_3 - x_1} \]

Cross-multiplying yields:
\[ x_2(x_3 - x_1) = x_3(x_2 - x_1) \]
\[ x_2 x_3 - x_2 x_1 = x_3 x_2 - x_3 x_1 \]

By commutativity of multiplication, $x_2 x_3 = x_3 x_2$, so:
\[ x_2 x_3 - x_2 x_1 = x_2 x_3 - x_3 x_1 \]

Subtracting $x_2 x_3$ from both sides:
\[ -x_2 x_1 = -x_3 x_1 \]

Since $x_1 \neq 0$ (as the secret lies at 0), we divide by $-x_1$ to obtain $x_2 = x_3$. This contradicts the fundamental requirement of Shamir's Secret Sharing that all share indices must be distinct. Therefore, $\gamma_1$ must change depending on the peer shares present.
\end{proof}

Consequently, the user must determine the correct coefficients based on the specific set of shares available at recovery time. To facilitate this, we propose two distinct workflows.

\subsubsection{Workflow A: Recovery with a Basic Calculator}
If a standard basic calculator is available, this workflow is generally faster and familiar to most users. The user looks up the integer values for the coefficients $\gamma_j$ (see Section \ref{sec:precomputed}) and performs the operation $S = y_j \times \gamma_j \pmod{2053}$.

Since standard solar calculators typically lack a modulo operator, the recommended keystroke sequence for computing $A \times B \pmod{2053}$ is:
\begin{enumerate}
    \item \textbf{Multiply}: Calculate the product $P = A \times B$.
    \item \textbf{Divide}: Compute $Q = P \div 2053$.
    \item \textbf{Truncate}: Identify the integer part of the quotient, $\lfloor Q \rfloor$ (e.g., if the display reads $717.04\dots$, use $717$).
    \item \textbf{Subtract}: The modular result is $P - (\lfloor Q \rfloor \times 2053)$.
\end{enumerate}
This sequence yields the exact modular product using only basic arithmetic operations.

\subsubsection{Workflow B: The Modular Lookup Strip}
For scenarios requiring strictly air-gapped recovery without electronic calculators, or to reduce the risk of manual long division errors, the scheme supports ``Modular Lookup Strips'' (analogous to Napier's Bones).

Based on the distributive property of modular arithmetic, any share value $Y$ ($0 \le Y \le 2052$) can be decomposed by place value:
\[ Y \cdot \gamma \equiv (d_3 1000 \gamma) + (d_2 100 \gamma) + (d_1 10 \gamma) + (d_0 \gamma) \pmod{2053} \]

For a specific coefficient $\gamma$, a pre-computed strip provides the modular product for all digits $0\dots9$ at each decimal position (Ones, Tens, Hundreds, Thousands).

To perform the multiplication $y_j \times \gamma_j$:
\begin{enumerate}
    \item The user locates the strip corresponding to $\gamma_j$.
    \item They look up the four values corresponding to the digits of $y_j$ (Thousands, Hundreds, Tens, Ones).
    \item They sum these four values.
    \item If the sum exceeds 2053, they subtract 2053 once (or rarely, twice) to find the result.
\end{enumerate}

This method transforms the complexity of long multiplication and division into four $O(1)$ table lookups and a single integer addition, significantly reducing the cognitive load and error rate for manual execution.

\subsection{Pre-Computed Coefficients for Common Schemes} \label{sec:precomputed}
For completeness, the following table lists pre-computed Lagrange coefficients $\gamma$ for selected small schemes in $GF(2053)$. Share indices are assumed to be consecutive integers starting from 1.

\begin{center}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{@{}llp{3.5cm}@{}}
\toprule
\textbf{Scheme} & \textbf{Shares Used} & \textbf{Coefficients ($\gamma$)} \\ \midrule
\textbf{2-of-3} & \{1, 2\} & (2, 2052) \\
                & \{1, 3\} & (1028, 1026) \\
                & \{2, 3\} & (3, 2051) \\ \midrule
\textbf{2-of-4} & \{1, 2\} & (2, 2052) \\
                & \{1, 3\} & (1028, 1026) \\
                & \{1, 4\} & (1370, 684) \\
                & \{2, 3\} & (3, 2051) \\
                & \{2, 4\} & (2, 2052) \\
                & \{3, 4\} & (4, 2050) \\ \midrule
\textbf{3-of-5} & \{1, 2, 3\} & (3, 2050, 1) \\
                & \{1, 2, 4\} & (687, 2051, 1369) \\
                & \{1, 2, 5\} & (1029, 1367, 1711) \\
                & \{1, 3, 4\} & (2, 2051, 1) \\
                & \{1, 3, 5\} & (1285, 512, 257) \\
                & \{1, 4, 5\} & (686, 1367, 1) \\
                & \{2, 3, 4\} & (6, 2045, 3) \\
                & \{2, 3, 5\} & (5, 2048, 1) \\
                & \{2, 4, 5\} & (1372, 2048, 687) \\
                & \{3, 4, 5\} & (10, 2038, 6) \\ \bottomrule
\end{tabular}%
}
\end{center}

\subsection{BIP39 Compatibility}
Schiavinato Sharing operates on standard BIP39 word indices and does not alter the wordlist. The only deviation arises when a share value lies in the range 2048--2052, which cannot be mapped to a BIP39 word. In this rare case, the recovery instructions direct the user to write down the numeric value itself. As a result, any recovered mnemonic that consists solely of indices in 0--2047 is a standard BIP39 phrase and is accepted by existing wallets without modification.

\section{Security Analysis}

\subsection{Threat Model and Scope}
Schiavinato Sharing is intended to protect the secrecy and recoverability of a BIP39 mnemonic under the following assumptions:
\begin{itemize}[noitemsep]
    \item An adversary may obtain, copy, or inspect \textbf{fewer than $k$} distinct shares for a given wallet.
    \item Legitimate participants can coordinate to obtain \textbf{at least $k$} valid shares when recovery is required.
\end{itemize}

Within this model, the goals of the scheme are:
\begin{itemize}[noitemsep]
    \item \textbf{Confidentiality}: Any set of fewer than $k$ shares should reveal no information about the underlying BIP39 mnemonic beyond what is already implied by its domain (approximately $2^{256}$ possibilities).
    \item \textbf{Integrity of recovery}: Given at least $k$ honest shares, the combination of row-level checks and the master verification number should detect accidental arithmetic or transcription errors with overwhelmingly high probability.
\end{itemize}

\subsection{Security Properties}
The security claims reduce to the standard properties of Shamir's scheme:
\begin{itemize}
    \item \textbf{Threshold property}: Any set of at least $k$ consistent shares determines the secret uniquely.
    \item \textbf{Information-theoretic secrecy}: For any $t < k$ shares, the distribution of shares is identical regardless of the secret value.
\end{itemize}

Because each of the 33 secrets is shared independently, knowledge of shares or even full recovery of one secret does not aid in recovering any other secret without the requisite number of shares.

\subsection{Human-Factor Vulnerabilities}
The primary risk is manual arithmetic errors. The two-layer checksum (Section \ref{sec:checksum}) mitigates this risk by providing localized feedback. From a usability perspective, the design offers a favorable trade-off: users perform only familiar operations (addition, multiplication, reduction) and receive immediate feedback at the row level.

\section{The GRIFORTIS Reference Implementation}

\subsection{The \texorpdfstring{\texttt{schiavinato-sharing.html}}{schiavinato-sharing.html} Tool}
The primary reference implementation is a single self-contained HTML/JavaScript file, intended to be executed on an air-gapped computer. Its design adheres to the following constraints:
\begin{itemize}
    \item \textbf{Offline by construction}: The file embeds all required assets and makes no network requests.
    \item \textbf{Verifiable distribution}: Each released version is accompanied by a published SHA-256 checksum.
    \item \textbf{Explicit threat model}: Users verify the checksum and transfer the file to an air-gapped machine.
\end{itemize}

Within these constraints, the tool offers Automated Sharding, Automated Recovery, Manual Sharding Helper, and a Manual Recovery Helper (Lagrange Calculator).

\subsection{The \texorpdfstring{\texttt{schiavinato\_sharing}}{schiavinato\_sharing} Libraries}
For developers and auditors, GRIFORTIS provides reference libraries in Python and JavaScript (with TypeScript declarations). These expose the core cryptographic operations:
\begin{itemize}
    \item \texttt{split\_bip39(mnemonic, k, n)}
    \item \texttt{recover\_bip39(shares)}
\end{itemize}

All reference implementations are released under the \textbf{MIT License}.

\section{Future Work}
\begin{itemize}
    \item \textbf{Usability Studies}: Conducting controlled user studies to compare the error rates and completion times of ``Workflow A'' (Calculator) versus ``Workflow B'' (Lookup Strip) for non-technical participants.
    \item \textbf{Formal Verification}: A machine-readable specification of the $GF(2053)$ arithmetic routines to enable formal verification of the implementation logic.
    \item \textbf{Hybrid Shares}: Integration of standard QR codes (e.g., `ur:crypto-share`) into the worksheet header to allow for instant digital recovery when trusted hardware is available, preserving the manual path as a fallback.
\end{itemize}

\section{Conclusion}
Schiavinato Sharing presents a human-centric adaptation of Shamir's Secret Sharing for BIP39 mnemonics. By operating directly on word indices in a small prime field and layering in robust arithmetic checksums, it enables manual recovery with only pencil and paper while preserving the information-theoretic security of the underlying scheme. The GRIFORTIS reference implementation demonstrates that such a scheme can be realized in a single auditable HTML file suitable for integration and scrutiny.

\section{References}

\begin{enumerate}[label={[\arabic*]}]

    % --- Foundational ---
    \item A. Shamir, ``How to share a secret,'' \textit{Communications of the ACM}, vol. 22, no. 11, pp. 612--613, Nov. 1979.
    
    \item G. R. Blakley, ``Safeguarding cryptographic keys,'' in \textit{Proceedings of the National Computer Conference}, 1979, vol. 48, pp. 313--317.

    % --- Human Computation & Usability ---
    \item J. Blocki, M. Blum, A. Datta, and S. Vempala, ``Towards Human Computable Passwords,'' in \textit{Innovations in Theoretical Computer Science (ITCS)}, 2014.
    
    \item S. Eskandari, D. Barrera, E. Stobert, and J. Clark, ``A First Look at the Usability of Bitcoin Key Management,'' in \textit{Workshop on Usable Security (USEC)}, 2015.
    
    \item V. Buterin, ``Why we need wide adoption of social recovery wallets,'' \textit{Vitalik.ca}, Jan. 2021. [Online]. Available: \url{https://vitalik.ca/general/2021/01/11/recovery.html}.

    % --- Verifiability & Robustness ---
    \item P. Feldman, ``A practical scheme for non-interactive verifiable secret sharing,'' in \textit{Proceedings of the 28th Annual Symposium on Foundations of Computer Science}, 1987, pp. 427--437.

    \item T. Rabin and M. Ben-Or, ``Verifiable secret sharing and multiparty protocols with honest majority,'' in \textit{Proceedings of the 21st Annual ACM Symposium on Theory of Computing (STOC)}, 1989, pp. 73--85.

    % --- Standards ---
    \item P. Wuille, et al., ``BIP-0032: Hierarchical Deterministic Wallets,'' \textit{Bitcoin Improvement Proposals}, 2012.
    
    \item M. Palatinus, et al., ``BIP-0039: Mnemonic code for generating deterministic keys,'' \textit{Bitcoin Improvement Proposals}, 2013.
    
    \item SatoshiLabs, ``SLIP-0039: Shamir's Secret-Sharing for Mnemonic Codes,'' \textit{SatoshiLabs Improvement Proposals}, 2019.

\end{enumerate}

\appendix

\section{A Primer on Shamir's Secret Sharing}
Shamir's Secret Sharing is a threshold scheme that allows a secret value to be split into $n$ shares such that any $k$ shares suffice to reconstruct the secret, while any $t < k$ shares provide no information about it.

At a high level:
\begin{enumerate}
    \item \textbf{Finite field}: Choose a finite field $GF(q)$. In this paper, $q = 2053$.
    \item \textbf{Polynomial encoding}: To share a secret $s \in GF(q)$, select a random polynomial
    \[ f(x) = a_0 + a_1 x + \dots + a_{k-1} x^{k-1} \]
    with $a_0 = s$ and $(a_1, \dots, a_{k-1})$ chosen uniformly at random from $GF(q)$.
    \item \textbf{Share generation}: For each participant index $x \in \{1, \dots, n\}$, compute the share $y = f(x)$.
    \item \textbf{Reconstruction}: Any group of $k$ participants can reconstruct the secret by interpolating the unique degree-$(k-1)$ polynomial that passes through their $k$ points.
\end{enumerate}

\section{Introduction to Modular Arithmetic}
Modular arithmetic behaves like ``clock arithmetic'': values wrap around after reaching a fixed modulus $p$.
\begin{itemize}
    \item \textbf{Addition}: $(2000 + 100) \pmod{2053} = 47$.
    \item \textbf{Multiplication}: $(1000 \times 3) \pmod{2053} = 947$.
    \item \textbf{Inversion}: When $p$ is prime, every non-zero element has a multiplicative inverse, enabling division.
\end{itemize}
Schiavinato Sharing pre-computes the necessary division operations (Lagrange coefficients) so users only perform multiplication and addition.

\section{Demystifying Lagrange Interpolation}
Lagrange interpolation provides a formula for reconstructing a polynomial from its values at a finite set of points. The interpolating polynomial is:
\[ f(x) = \sum_{j=1}^{k} y_j \ell_j(x) \]
where $\ell_j(x)$ are the Lagrange basis polynomials. Evaluating at $x=0$ yields the secret $a_0 = \sum_{j=1}^{k} y_j \gamma_j$, where $\gamma_j = \ell_j(0)$. This linear combination is the basis of the manual recovery workflow.

\section{Worked Example (Toy Model $p=13$)}
To illustrate the mechanics, we use a small prime $p = 13$ and a 2-of-3 scheme.

\paragraph{1. Setup}
Secret $s = 3$ (Word A). Checksum $c = 2$.
Polynomial for A: $f_A(x) = 3 + 4x \pmod{13}$.
Polynomial for c: $f_c(x) = 2 + 9x \pmod{13}$.

\paragraph{2. Share Generation}
\begin{itemize}[noitemsep]
    \item $x=1$: $A_1 = 3 + 4(1) = 7$. $c_1 = 2 + 9(1) = 11$.
    \item $x=3$: $A_3 = 3 + 4(3) = 15 \equiv 2$. $c_3 = 2 + 9(3) = 29 \equiv 3$.
\end{itemize}

\paragraph{3. Recovery (Shares 1 and 3)}
Lagrange coefficients for $\{1, 3\}$ in $GF(13)$ are $\gamma_1 = 8, \gamma_3 = 6$.
\begin{itemize}
    \item Recover A: $8(7) + 6(2) = 56 + 12 = 68 \equiv 3 \pmod{13}$. (Correct)
    \item Recover c: $8(11) + 6(3) = 88 + 18 = 106 \equiv 2 \pmod{13}$. (Correct)
\end{itemize}
This identical logic applies to $GF(2053)$ with larger numbers.

\section{Heir Instructions}
\textit{(Summary for Executors)}
\begin{itemize}
    \item \textbf{Not a Wallet}: Each sheet is a \textit{share}. A single sheet cannot recover funds.
    \item \textbf{Threshold}: You need $k$ distinct sheets (e.g., 3 sheets for a 3-of-5 scheme).
    \item \textbf{Do Not Type}: Do not enter words from a single share into a wallet. It will generate an empty, unrelated wallet.
    \item \textbf{Recovery}: Use the provided offline tool or a manual calculation service to combine the shares into the final 24-word phrase.
\end{itemize}

\section{Dice-Based Randomness for $GF(2053)$}
To generate a uniform integer in $\{0, \dots, 2052\}$ using 5 six-sided dice ($d_1 \dots d_5$):

\begin{enumerate}
    \item \textbf{Roll}: Roll 5 dice.
    \item \textbf{Convert to Base-6}: Calculate $N$:
    \[ N = \sum_{i=1}^{5} (d_i - 1) \cdot 6^{5-i} \]
    (This yields a value $0 \le N \le 7775$).
    \item \textbf{Rejection Sampling}:
    \begin{itemize}
        \item If $N \ge 6159$: \textbf{Discard} and re-roll.
        \item If $N < 6159$: Accept and compute coefficient $a = N \pmod{2053}$.
    \end{itemize}
\end{enumerate}
This provides cryptographically secure, unbiased entropy without a computer.

\end{document}

